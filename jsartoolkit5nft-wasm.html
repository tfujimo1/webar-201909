<html>
<head>
    <title>webAR</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
    <style>
html,body {
	margin: 0;
	padding: 0;
	width: 100%;
	text-align: center;
	overflow-x: hidden;
}
.portrait canvas {
	transform-origin: 0 0;
	transform: rotate(-90deg) translateX(-100%);
}
.desktop canvas {
 	transform: scale(-1, 1);
}

    </style>
</head>
<body>
<script type='text/javascript'>
      var artoolkit_wasm_url = 'artoolkitNft_wasm.wasm';

</script>
<script src="artoolkitNft_wasm.js"></script>
<script async src="three.min.js"></script>
<script async src="artoolkit.three.js"></script>

<script>
    window.addEventListener('artoolkit-loaded', () => {
      window.ARThreeOnLoad = function() {
      	ARController.getUserMediaThreeScene({maxARVideoSize: 320, cameraParam: 'camera_para-iPhone 5 rear 640x480 1.0m.dat',
      	onSuccess: function(arScene, arController, arCamera) {
      		document.body.className = arController.orientation;
      		var renderer = new THREE.WebGLRenderer({antialias: true});
      		if (arController.orientation === 'portrait') {
      			var w = (window.innerWidth / arController.videoHeight) * arController.videoWidth;
      			var h = window.innerWidth;
      			renderer.setSize(w, h);
      			renderer.domElement.style.paddingBottom = (w-h) + 'px';
      		} else {
      			if (/Android|mobile|iPad|iPhone/i.test(navigator.userAgent)) {
      				renderer.setSize(window.innerWidth, (window.innerWidth / arController.videoWidth) * arController.videoHeight);
      			} else {
      				renderer.setSize(arController.videoWidth, arController.videoHeight);
      				document.body.className += ' desktop';
      			}
      		}
      		document.body.insertBefore(renderer.domElement, document.body.firstChild);

      		// ジオメトリの作成
            const geometry = new THREE.PlaneGeometry(25, 25);

            // 画像ファイル名
            var pictures = [
            "test1.jpg",
            "test2.jpg",
            "test3.jpg"
            ]

            // マテリアルの作成
            var material = [];
            for(var p of pictures){
                material.push(new THREE.MeshBasicMaterial({map:THREE.ImageUtils.loadTexture(p)}));
            }

            // メッシュの作成
            var mesh = [];
            for(var m of material){
                var obj = new THREE.Mesh(geometry, m);
                obj.position.z = 0;
                obj.position.x = 0;
                obj.position.y = 0;
                obj.scale.set(1, 1, 1);
                mesh.push(obj);
            }

            // シーンの追加
            function addScene(){
                markerRoot.add(mesh[0]);
                arScene.scene.add(markerRoot);
            }

            // シーンの削除
            function delScene(){
                markerRoot.remove(markerRoot.children[0]);
            }

            // マーカーの読み込み
            var markerRoot;
            arController.loadNFTMarker('DataNFT/marker', function(markerId) {
                markerRoot = arController.createThreeNFTMarker(markerId);
                addScene();
            });

            // マーカーの追従と3Dオブジェクトの描画
            var count = 0;
            const tri = 30;
            var tick = function() {
                    count++;
                    if(count === tri){
                    mesh.push(mesh[0]);
                    mesh.shift();
                    delScene();
                    addScene();
                    count = 0;
                }
                arScene.process();
                arScene.renderOn(renderer);
                requestAnimationFrame(tick);
            };
      		tick();
      	}});
      	delete window.ARThreeOnLoad;
      };
      if (window.ARController && ARController.getUserMediaThreeScene) {
      	ARThreeOnLoad();
      }
});

class FpsCalculator {
  constructor() {
    this._isRunning = false;
    this._beginTime = Date.now();
    this._prevTime = this._beginTime;
    this._frames = 0;
  }
  start() {
    if (this._isRunning) {
      return null;
    }

    this._beginTime = Date.now();
    this._prevTime = this._beginTime;
    this._frames = 0;

    this._isRunning = true;
    const loop = () => {
      if (!this._isRunning) {
        return null;
      }
      this._update();
      requestAnimationFrame(loop);
    }
    loop();
  }
  stop() {
    this._isRunning = false;
    this._frames = 0;
  }
  _update() {
    this._frames++;
    let prevTime = this._prevTime;
    let time = Date.now();

    if (time > prevTime + 1000) {
      console.log((this._frames * 1000) / (time - prevTime));
      this._prevTime = time;
      this._frames = 0;
    }

    this._beginTime = time;
  }
}
const calculator = new FpsCalculator();
calculator.start();
</script>
</body>
</html>